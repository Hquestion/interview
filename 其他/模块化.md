# 模块化

## 什么是模块化

+ 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起

+ 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信

## 模块化的作用

+ 减少污染全局命名空间，避免命名冲突

+ 提高代码复用性

+ 提升代码可维护性

+ 更好的分离代码，让我们有按需加载的能力


## 各模块化方案的区别

### 命名空间

通过Object的方式，将模块的代码作为对象的属性封装在对象内。

+ 优点：减少全局变量，避免命名冲突
+ 缺点：可以直接获取到模块对象，可以修改内部变量，不安全

### 自执行函数

将模块代码放在自执行函数内，利用函数作用域确保内部变量不可被外界随意修改。

+ 优点：解决私有变量的问题，外部只能通过模块暴露的API操作
+ 问题：如果模块依赖其他库怎么办？

### 自执行函数增强

通过向自执行函数传参，来明确该模块的依赖关系，也保证模块的相对独立性


> 以上几种方式的弊端：

> 1.如果依赖多个模块，通过script标签引用会导致请求数量变多

> 2.各个script标签之间的依赖模糊，很容易因为加载顺序错误导致出错

> 3.上面两种情况导致维护困难

### AMD规范

异步加载模块，推崇依赖前置，依赖加载完成之后执行回调函数。
通过define来定义模块，通过require来加载模块。

+ 优点：依赖清晰，不会污染全局命名空间
+ 缺点：必须等依赖全部加载完成之后，才会执行回调函数

### CMD规范

异步加载模块，依赖的模块在使用时才会加载。推崇依赖就近，即使用时才加载模块
通过define(function(require, exports, module) {})来定义模块，通过require来加载模块

+ 优点：按需加载
+ 缺点：构建过度依赖spm

### CommonJS规范

Nodejs中使用，每个文件就是一个模块，有自己的作用域，内部的函数，变量等都是私有的，
其他模块不可见。模块是同步加载的，在浏览器端也可以使用，需提前编译打包。

+ 特点：同步加载，加载顺序即代码顺序；变量声明都在模块作用域内，不会污染全局空间；模块只在第一次加载时运行，然后会存入缓存。

### ES6模块

ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。

## 模块加载的机制

+ 自执行函数等：script标签引用，需按依赖关系保证加载顺序
+ AMD：依赖前置，需先加载完依赖才执行回调函数
+ CMD：依赖就近，按需加载
+ CommonJS：同步加载，输出的是值的拷贝
+ ES6模块：输出的是值的引用，在代码解析阶段就会生成对外接口

## 题目


> 【T3面试题】一个页面内，同时用zepto和jquery，怎么整合？

心中一定要有模块化的解决方案。这题主要考察模块化的一个作用：避免命名冲突。这里可以考虑自执行函数，requirejs,Commonjs
以及ES6模块等对这个问题的解决方案。同时衍生模块化的其他功能，如：提高代码可维护性，提高代码复用性
